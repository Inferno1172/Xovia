    <!doctype html>
    <html lang="en">
    <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Two Chairs - XOVIA Wellness</title>
    <style>
    :root{
        --amber:#F1A63A; --amber-dark:#E1931F;
        --wall:#FFF6E9;  --line:#e9ded3;
        --text:#2B1E12;  --muted:#7c6d61;
        --green:#65D6B0; --pink:#F08AC1;
        --shadow:0 10px 30px rgba(0,0,0,.12);
        --card:#FFFFFF;
        --lumen:#ffffff; --lumen-line:#e7dacd;
        --error:#e74c3c; --success:#27ae60;
        --dockH: 120px;
        --chatGap: 8px;
        --stackH: 140px;
    }

 html, body {
    height: auto;
    min-height: 100%;
}

body {
    margin: 0;
    background: #000;
    display: block; /* <-- removed flex centering */
    font-family: system-ui,Segoe UI,Roboto,Helvetica,Arial;
    color: var(--text);
}


   .phone{
    width:min(420px,100%);
    min-height:100dvh;
    background:var(--wall);
    display:flex; flex-direction:column;
    position:relative;
    margin: 0 auto; /* <-- center horizontally */
}


    .chairs-dock{
        position:absolute;
        left:0; right:0;
        bottom: var(--stackH);
        height: var(--dockH);
        z-index:2;
        pointer-events:none;
    }

    .floor-line{
        position:absolute;
        left:16px;
        right:16px;
        bottom: var(--stackH);
        height:1px;
        background: var(--line);
        z-index: 1;
    }

    .status-bar{
        position:absolute; top:10px; left:16px; z-index:10;
        font-size:11px; color:var(--muted); display:none;
    }
    .status-bar.error{ color:var(--error); display:block; }
    .status-bar.connecting{ color:var(--muted); display:block; }

    .appbar{
        background:linear-gradient(180deg,var(--amber),var(--amber-dark));
        color:#3b220b; padding:14px 16px;
        display:flex; align-items:center; gap:12px; box-shadow:var(--shadow);
        position:relative;
    }
    .avatar{width:40px;height:40px;border-radius:50%;background:#8e6bff;}
    .title{font-weight:800}
    .actions { margin-left:auto; display:flex; align-items:center; gap:10px; }
    .burger{
        width:28px;height:20px;position:relative; cursor:pointer;
    }
    .burger::before,.burger::after,.burger span{content:"";position:absolute;left:0;right:0;height:3px;background:#4b2e0d;border-radius:3px}
    .burger::before{top:0}.burger span{top:8px}.burger::after{bottom:0}
    .helpbtn {
        margin-left: 8px;
        width: 28px; height: 28px;
        border-radius: 50%;
        border: 2px solid #4b2e0d;
        background: transparent;
        color: #4b2e0d;
        font-weight: 800;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all .2s ease;
    }
    .helpbtn:hover {
        background:#f3e2c0;
        transform: translateY(-1px);
    }

    .scene{position:relative; padding:14px 16px 0; flex:1; display:flex; flex-direction:column;}
    .room{
        position:relative;
        height:280px;
        background:var(--wall);
        padding-top:44px;
        padding-bottom: calc(var(--dockH) + var(--chatGap));
        overflow:hidden;
        flex-shrink:0;
    }

    .pills{
        position:absolute; top:10px; right:12px; display:flex; gap:6px; z-index:3;
    }
    .pill{
        width:20px; height:7px; border-radius:999px; background:#f0e5d8;
        border:1px solid #e5d2bf; transition:all 0.3s ease;
    }
    .pill.on{ background:#6fd0c6; border-color:#54b9ae; }

    .timeline{
        position:absolute; left:16px; right:16px;
        top:44px;
        bottom: calc(var(--dockH) + var(--chatGap));
        overflow-y:auto;
        padding-bottom:8px;
        display:flex; flex-direction:column; gap:8px;
        scroll-behavior:smooth;
        z-index:1;
        mask: linear-gradient(to bottom, white 0%, white calc(100% - 20px), transparent 100%);
        -webkit-mask: linear-gradient(to bottom, white 0%, white calc(100% - 20px), transparent 100%);
    }

    .entry{ display:flex; animation:fadeIn 0.3s ease-in; }
    .entry.self{ justify-content:flex-start }
    .entry.monster{ justify-content:flex-end }
    .entry.lumen{ justify-content:center }

    @keyframes fadeIn {
        from { opacity:0; transform:translateY(10px); }
        to { opacity:1; transform:translateY(0); }
    }

    .bubble{
        max-width:82%;
        padding:10px 12px; border-radius:14px; line-height:1.35;
        box-shadow:var(--shadow); border:1px solid var(--line);
        word-wrap:break-word; white-space:pre-wrap; background:#fff;
        position:relative;
    }
    .entry.self .bubble{ background:#BFEFE8; color:#063a34; border-color:#6fd0c6 }
    .entry.monster .bubble{ background:#FFD7EC; color:#4b2340; border-color:#e6a6c7 }
    .entry.lumen .bubble{ background:#fff; color:#2b1e12; border-color:var(--lumen-line) }
    .tag{ font-size:11px; color:var(--muted); margin:2px 2px 0; text-align:center; font-weight:600; }
    .tag.left{text-align:left} .tag.right{text-align:right}

    .typing .bubble{ display:flex; align-items:center; gap:8px }
    .dots{ display:none; min-width:18px }
    .typing .dots { display: inline-block; }
    .dots span{
        display:inline-block; width:6px; height:6px; border-radius:50%;
        background:#c9bdae; margin:0 2px; opacity:.5; animation:blink 1.2s infinite;
    }
    .dots span:nth-child(2){ animation-delay:.2s }
    .dots span:nth-child(3){ animation-delay:.4s }
    @keyframes blink { 0%,80%,100%{opacity:.3} 40%{opacity:1} }

    .chair{
        position:absolute;
        bottom:8px;
        width:120px;
        height:100px;
        z-index:2;
        pointer-events:auto;
    }
    .left{ left:28px; }
    .right{ right:28px; }

    .seat{
        position:absolute;left:0;right:0;bottom:0;height:45px;
        background:#4e3a2d;border-radius:12px;
    }

    /* Give the whole chair a bit of depth/perspective */
.chair{
  perspective: 600px;
}

/* Backrest */
.back{
  position:absolute; left:-2px; right:-2px; bottom:40px; height:54px;
  border-radius:14px;
  background:
    linear-gradient(180deg, #6a4f3e 0%, #4e3a2d 100%);
  border:1px solid rgba(0,0,0,.12);
  box-shadow:
    inset 0 6px 10px rgba(255,255,255,.08),
    inset 0 -6px 10px rgba(0,0,0,.15);
  transform: translateZ(-6px) rotateX(6deg);
  z-index:1;
}

/* Seat cushion (top + subtle bevel) */
.seat{
  position:absolute; left:-4px; right:-4px; bottom:0; height:48px;
  border-radius:16px;
  background:
    linear-gradient(180deg, #5a4335 0%, #3f2f25 100%);
  border:1px solid rgba(0,0,0,.18);
  box-shadow:
    inset 0 10px 16px rgba(255,255,255,.06),
    inset 0 -8px 18px rgba(0,0,0,.25),
    0 6px 12px rgba(0,0,0,.20);
  z-index:2;
}

/* Little front legs */
.leg{
  position:absolute; bottom:0; width:10px; height:22px;
  border-radius:6px;
  background: linear-gradient(180deg, #6b5242 0%, #3a2b22 100%);
  box-shadow: 0 2px 4px rgba(0,0,0,.2);
  z-index:0;
}
.leg.l{ left:6px; }
.leg.r{ right:6px; }

/* Soft floor shadow for the whole chair */
.floorshadow{
  position:absolute; left:-8px; right:-8px; bottom:-6px; height:18px;
  background: radial-gradient(50% 70% at 50% 50%, rgba(0,0,0,.25) 0%, rgba(0,0,0,0) 70%);
  filter: blur(2px);
  transform: translateZ(-10px);
  z-index:0;
}

/* Make the blob sit "into" the chair a bit */
.blob{
  box-shadow:
    0 10px 20px rgba(0,0,0,.12),
    inset 0 0 0 0 transparent; /* keep clean */
  transform-origin: center bottom;
}

/* When the character is talking, add a tiny reactive tilt/bounce to the chair */
.chair.speaking .back{
  transform: translateZ(-6px) rotateX(6deg) translateY(-1px);
  transition: transform .22s ease;
}
.chair.speaking .seat{
  transform: translateY(-1px);
  transition: transform .22s ease, box-shadow .22s ease;
  box-shadow:
    inset 0 12px 18px rgba(255,255,255,.07),
    inset 0 -10px 20px rgba(0,0,0,.28),
    0 8px 16px rgba(0,0,0,.24);
}
.chair.speaking .floorshadow{
  transform: translateZ(-10px) scaleX(1.02);
  transition: transform .22s ease, filter .22s ease;
  filter: blur(2.6px) brightness(.95);
}

/* Slight focus cue when character is active (awaiting input) */
.chair.active .seat{
  box-shadow:
    inset 0 12px 18px rgba(255,255,255,.08),
    inset 0 -10px 22px rgba(0,0,0,.30),
    0 10px 18px rgba(0,0,0,.26);
  transition: box-shadow .25s ease;
}

    
    /* FIXED BLOB ANIMATIONS */
   .blob{
  position:absolute; bottom:25px; left:13px;
  width:95px; height:85px;
  border-radius:30px;
  background:var(--green);
  z-index:3;
  transform-origin:center center;

  /* transitions should NOT fight keyframe anims; limit to transform only */
  transition: transform .28s cubic-bezier(.22,.61,.36,1);
  will-change: transform;

  /* Default idle state */
  animation: idle-breathe 4s ease-in-out infinite;
}


    .right .blob{background:var(--pink);}

    /* State-based animation overrides */
    
    .blob.state-active    { animation: active-glow 3s ease-in-out infinite; }
/* Talking glow ‚Äî strong enough on a bright wall */
.blob.state-talking{
  animation: talk-bounce .8s ease-in-out infinite, talk-glow-green 1.4s ease-in-out infinite;
  box-shadow:
    0 0 26px 10px rgba(101,214,176,.45),
    0 0 10px  2px rgba(101,214,176,.35);
}
.right .blob.state-talking{
  animation: talk-bounce .8s ease-in-out infinite, talk-glow-pink 1.4s ease-in-out infinite;
  box-shadow:
    0 0 26px 10px rgba(240,138,193,.45),
    0 0 10px  2px rgba(240,138,193,.35);
}



    .blob.state-listening { animation: listen-sway 3s ease-in-out infinite; }

    /* idle is the default, already set above */

    

    /* Animation keyframes */

    @keyframes idle-breathe {
        0%, 100% { transform:scale(1) translateY(0) rotate(0deg); }
        50% { transform:scale(1.02) translateY(-2px) rotate(0deg); }
    }
    @keyframes active-glow {
        0%, 100% { transform: scale(1.03) translateY(-1px) rotate(0deg); }
        50% { transform: scale(1.06) translateY(-3px) rotate(0.5deg); }
    }
    @keyframes talk-bounce {
        0%, 100% { transform: scale(1.08) translateY(-3px) rotate(0deg); }
        50% { transform: scale(1.12) translateY(-6px) rotate(1deg); }
    }
    @keyframes listen-sway {
        0%, 100% { transform: scale(0.96) translateY(1px) rotate(0deg); }
        33% { transform: scale(0.97) translateY(0px) rotate(0.5deg); }
        66% { transform: scale(0.96) translateY(1px) rotate(-0.3deg); }
    }

    .eye{
        position:absolute;width:14px;height:14px; border-radius:50%;top:20px;left:27px;
        background:#000;box-shadow:0 0 0 3px #fff inset;
        transition:all 0.3s ease; animation:eye-blink 6s ease-in-out infinite;
    }
    .left .eye{ left:auto; right:27px; }
    .right .eye{ left:27px; right:auto; }
    @keyframes eye-blink {
        0%, 90%, 100% { transform:scaleY(1); }
        95% { transform:scaleY(0.1); }
    }

    .state-talking .eye { animation:eye-excited 0.4s ease-in-out infinite alternate; }
    @keyframes eye-excited { 0% { transform:scale(1); } 100% { transform:scale(1.1); } }

    .arm{
        position:absolute;width:35px;height:12px;
        background:#ddd;border-radius:6px;bottom:32px;left:-5px;
        transition:all 0.3s ease;
    }
    .right .arm{left:auto;right:-5px}
    .state-talking .arm { animation:arm-gesture 1.2s ease-in-out infinite; }
    @keyframes arm-gesture {
        0%, 100% { transform:rotate(0deg) translateY(0); }
        25% { transform:rotate(10deg) translateY(-2px); }
        75% { transform:rotate(-5deg) translateY(1px); }
    }

    .cards{padding:10px 16px 8px;display:grid;gap:8px; flex-shrink:0;}
    .card{
        background:var(--card);border:1px solid var(--line);border-radius:16px;
        padding:10px 12px;box-shadow:var(--shadow); transition:transform 0.2s ease;
    }
    .card:hover{ transform:translateY(-2px); }
    .card h4{margin:0 0 4px;color:#7a6a5f;font-size:12px;font-weight:800;letter-spacing:.2px}
    .card .ghost{background:#f7efe7;padding:8px 10px;border-radius:12px;font-weight:700;color:#4a3d35}
    .card .ghost small{color:var(--muted);font-weight:600}

    .composer{
        margin:0 16px 16px;display:flex;gap:10px;background:#fff;
        border:1px solid var(--line);border-radius:16px;padding:10px;box-shadow:var(--shadow);
        flex-shrink:0;
    }
    .composer.disabled{ opacity:0.6; pointer-events:none; }
    textarea{
        flex:1;resize:vertical;min-height:84px;border:0;outline:0;font-size:14px;
        font-family:inherit; transition:box-shadow 0.2s ease;
    }
    textarea:focus{ box-shadow:0 0 0 2px var(--amber); border-radius:8px; }
    .send{
        background:var(--amber);border:0;padding:10px 14px;border-radius:14px;
        font-weight:800;cursor:pointer;box-shadow:inset 0 4px 0 #d78613;
        transition:all 0.2s ease; color:#3b220b; font-size:14px;
    }
    .send:hover:not(:disabled){ transform:translateY(-1px); box-shadow:inset 0 5px 0 #d78613; }
    .send:active{ transform:translateY(0); box-shadow:inset 0 2px 0 #d78613; }
    .send:disabled{opacity:.6;cursor:not-allowed; transform:none; }

    .error-message{
        background:#fee; border:1px solid #fcc; color:#c33;
        padding:8px 12px; border-radius:8px; margin:8px 16px;
        font-size:12px; display:none;
    }
    .error-message.show{ display:block; animation:fadeIn 0.3s ease; }

    .modal{
        position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;
        align-items:center;justify-content:center;padding:16px;z-index:90;
    }
    .modal.open{display:flex;}
    .sheet{
        max-width:420px;
        width:100%;
        background:#fff;
        border-radius:22px;
        border:1px solid var(--line);
        box-shadow:var(--shadow);
        overflow:hidden;
        animation:modalSlideIn 0.3s ease;
    }
    @keyframes modalSlideIn {
        from { opacity:0; transform:translateY(30px) scale(0.95); }
        to { opacity:1; transform:translateY(0) scale(1); }
    }
    .sheet .head{
        padding:14px 16px;border-bottom:1px solid var(--line);
        background:linear-gradient(180deg,#fff7e9,#fff);
    }
    .sheet .title{font-weight:800;color:#4b2e0d}
    .sheet .body{padding:16px; max-height:60vh; overflow-y:auto;}
    .sheet .actions{display:flex;justify-content:flex-end;gap:10px;padding:10px 16px 16px;}
    .btn{
        appearance:none;border:1px solid var(--line);background:#fafafa;
        border-radius:12px;padding:8px 12px;font-weight:700;cursor:pointer;
        transition:all 0.2s ease;
    }
    .btn:hover{ background:#f0f0f0; transform:translateY(-1px); }
    .btn.primary{background:var(--amber);border-color:#d78613;color:#3b220b}
    .btn.primary:hover{ background:#e09528; }

    .sos{
        position:fixed; inset:0; display:none; align-items:center;
        justify-content:center; padding:16px; z-index:100;
        background:rgba(0,0,0,.6); backdrop-filter:blur(4px);
    }
    .sos.open{display:flex}
    .soscard{
        max-width:420px; width:100%; border-radius:20px; overflow:hidden;
        box-shadow:0 20px 50px rgba(0,0,0,.4); border:1px solid var(--line);
        background:#fff; animation:modalSlideIn 0.4s ease;
    }
    .soshead{
        background:linear-gradient(135deg, #ffe6a6 0%, #ffd1e6 55%, #fff 100%);
        padding:18px 16px; border-bottom:1px solid var(--line);
    }
    .sostitle{
        font-weight:900; font-size:18px; color:#3b2a1d;
        display:flex; align-items:center; gap:10px
    }
    .sosbody{padding:16px; color:#2b1e12}
    .sosbody p{margin:0 0 8px}
    .soslist{display:grid; gap:8px; margin:10px 0 0}
    .pillbtn{
        display:flex; align-items:center; gap:10px; padding:10px 12px;
        border-radius:14px; border:1px solid var(--line); background:#fffdfa;
        font-weight:800; text-decoration:none; color:#3b220b;
        transition:all 0.2s ease;
    }
    .pillbtn:hover{ background:#f9f7f4; transform:translateY(-1px); }
    .sosactions{display:flex; justify-content:flex-end; gap:8px; padding:12px 16px 16px}

    @media (max-height: 600px) {
        .room{ height:220px; }
        .composer textarea{ min-height:60px; }
        .chair{ height:80px; }
        .blob{ width:75px; height:65px; bottom:20px; }
    }
    @media (max-width: 380px) {
        .appbar{ padding:12px 14px; }
        .scene{ padding:12px 14px 0; }
        .composer{ margin:0 14px 14px; }
        .cards{ padding:8px 14px 6px; }
    }

    .loading { position:relative; overflow:hidden; }
    .loading::after {
        content:'';
        position:absolute; top:0; left:-100%; right:100%; bottom:0;
        background:linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
        animation:shimmer 1.5s infinite;
    }
    @keyframes shimmer {
        0% { left:-100%; right:100%; }
        100% { left:100%; right:-100%; }
    }
    @keyframes talk-glow-green {
  0%,100% { box-shadow: 0 0 6px rgba(101,214,176,0.0); }
  50%     { box-shadow: 0 0 20px rgba(101,214,176,0.7); }
}
@keyframes talk-glow-pink {
  0%,100% { box-shadow: 0 0 6px rgba(240,138,193,0.0); }
  50%     { box-shadow: 0 0 20px rgba(240,138,193,0.7); }
}



    @media (prefers-reduced-motion: reduce) {
    /* Turn off decorative shimmer/hover transitions only */
    .loading::after,
    .card:hover,
    .btn:hover,
    .send:hover {
        animation: none !important;
        transition: none !important;
    }
    /* Keep blobs & typing dots alive: do NOT override their animations */
    }


    .send:focus, .btn:focus, textarea:focus {
        outline: 2px solid var(--amber);
        outline-offset: 2px;
    }
    @media (prefers-contrast: high) {
        :root { --shadow: 0 2px 4px rgba(0,0,0,0.5); }
        .bubble { border-width: 2px; }
    }
    </style>
    </head>
    <body>
    <div class="phone">
        <!-- Status bar for connection feedback -->
        <div id="statusBar" class="status-bar" aria-live="polite"></div>

        <!-- header -->
        <div class="appbar">
   <img src="xovia.jpg" alt="XOVIA Wellness Logo" class="avatar">
    <div class="title">XOVIA Wellness</div>
    <div class="actions">
        <button class="helpbtn" id="helpBtn" aria-label="Help" title="Help">?</button>
        <div class="burger" role="button" tabindex="0" aria-label="Menu"><span></span></div>
    </div>
    </div>



        <!-- Error message area -->
        <div id="errorMessage" class="error-message" role="alert"></div>

        <!-- scene -->
        <div class="scene">
        <div class="room">
            <!-- progress -->
            <div class="pills" id="pills" aria-label="Progress indicator">
            <div class="pill" id="p0" aria-label="Step 1"></div>
            <div class="pill" id="p1" aria-label="Step 2"></div>
            <div class="pill" id="p2" aria-label="Step 3"></div>
            <div class="pill" id="p3" aria-label="Step 4"></div>
            <div class="pill" id="p4" aria-label="Step 5"></div>
            <div class="pill" id="p5" aria-label="Step 6"></div>
            </div>

            <!-- stacked chat history -->
            <div id="timeline" class="timeline" role="log" aria-live="polite" aria-label="Conversation"></div>
        </div>

        </div> <!-- end .scene -->

    <div class="floor-line" aria-hidden="true"></div>  <!-- ‚Üê add this -->

    <!-- chairs docked to the bottom stack (sibling of .scene) -->
    <!-- chairs docked to the bottom stack (sibling of .scene) -->
    <div class="chairs-dock" aria-hidden="true">
  <div class="chair left">
    <div class="back"></div>
    <div class="seat"></div>
    <div class="leg l"></div>
    <div class="leg r"></div>
    <div class="floorshadow"></div>
    <div class="blob" id="selfBlob"><div class="eye"></div></div>
    <div class="arm"></div>
  </div>
  <div class="chair right">
    <div class="back"></div>
    <div class="seat"></div>
    <div class="leg l"></div>
    <div class="leg r"></div>
    <div class="floorshadow"></div>
    <div class="blob" id="monsterBlob"><div class="eye"></div></div>
    <div class="arm"></div>
  </div>
</div>



    <!-- chairs docked to the bottom stack (sibling of .scene) -->
        <!-- condensed helper cards -->
        <div class="cards" id="cards">
        <div class="card">
            <h4>What do you want to talk about?</h4>
            <div class="ghost"><small>Eg.</small> Exam tomorrow.</div>
        </div>
        <div class="card">
            <h4>How do you feel?</h4>
            <div class="ghost"><small>Eg.</small> "I'm worried I didn't study enough."</div>
        </div>
        </div>

        <!-- composer -->
        <div class="composer" id="composer">
        <textarea
            id="t"
            placeholder="Type as SELF‚Ä¶"
            aria-label="Message input"
            maxlength="2000"
        ></textarea>
        <button id="send" class="send" aria-label="Send message">Send</button>
        </div>
    </div>

    <!-- Lumen Reflection modal -->
    <div class="modal" id="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
        <div class="sheet">
        <div class="head">
            <div class="title" id="modalTitle">Lumen's Reflection</div>
        </div>
        <div class="body">
            <div id="modalText" role="main"></div>
        </div>
        <div class="actions">
            <button class="btn" id="copyBtn" aria-label="Copy reflection text">Copy</button>
            <button class="btn primary" id="closeBtn" aria-label="Close reflection">Close</button>
        </div>
        </div>
    </div>

    

    <!-- Help sheet (styled like SOS) -->
    <div class="sos" id="help" role="dialog" aria-modal="true" aria-labelledby="helpTitle" aria-hidden="true">
        <div class="soscard">
        <div class="soshead">
            <div class="sostitle" id="helpTitle">‚ùì Two Chairs ‚Äì How it works</div>
        </div>
        <div class="sosbody">
            <p><strong>Two Chairs Dialogue</strong></p>
            <p>This is a short exercise where your "True Self" and your "Inner Critic (Monster)" take turns.</p>
            <ul>
            <li><strong>Step 1:</strong> Write as your True Self (what you hope, believe, or want).</li>
            <li><strong>Step 2:</strong> Write as your Monster (the discouraging voice).</li>
            </ul>
            <p>Repeat for <strong>3 exchanges</strong> (Self ‚Üí Monster) √ó 3. After that, Lumen will respond with support and one practical next step.</p>
        </div>
        <div class="sosactions">
            <button class="btn" id="helpClose" aria-label="Close help">Close</button>
        </div>
        </div>
    </div>

    <!-- Enhanced SOS sheet -->
    <div class="sos" id="sos" role="dialog" aria-modal="true" aria-labelledby="sosTitle">

        <div class="soscard">
        <div class="soshead">
            <div class="sostitle" id="sosTitle">‚ö† We're here with you</div>
        </div>
        <div class="sosbody">
            <p id="sosMsg">We identified harmful words in your conversation. Life is worth living ‚Äî you are not alone.</p>
            <div class="soslist">
            <a id="sosLink" class="pillbtn" href="#" target="_blank" rel="noopener" aria-label="Get help and hotlines">
            üîó See Help & Hotlines
            </a>
            <a id="sosResources" class="pillbtn" href="#" target="_blank" rel="noopener" aria-label="Open safety resources">
            üìò Open Safety Resources
            </a>

            </div>
        </div>
        <div class="sosactions">
            <button class="btn" id="sosClose" aria-label="Close safety message">Close</button>
            <button class="btn primary" id="sosReset" aria-label="Start new conversation">Start New</button>
        </div>
        </div>
    </div>

    <script>
    (() => {
    // ---------- Config ----------
    const BASE = "http://127.0.0.1:3000";
    const SPEED_CHAR_CHAT_LUMEN = 8;
    const SPEED_CHAR_MODAL      = 10;
    const MAX_RETRIES = 3;
    const RETRY_DELAY = 1000;
    const SPEAK_TAIL = 280; // ms to gently linger before resetting


    // ---------- State ----------
    let sessionId = null;
    let role = "self";
    let steps = 0;
    let inFlight = false;
    let focusAfterSend = false;   // will request focus after UI re-enables

    // ---------- Elements ----------
    const phone = document.querySelector(".phone");
    const cards = document.getElementById("cards");
    const composer = document.getElementById("composer");
    const t = document.getElementById("t");
    const sendBtn = document.getElementById("send");
    const timeline = document.getElementById("timeline");
    const pills = Array.from({length:6}, (_,i)=> document.getElementById("p"+i));
    const statusBar = document.getElementById("statusBar");
    const errorMessage = document.getElementById("errorMessage");
    const selfBlob = document.getElementById("selfBlob");
    const monsterBlob = document.getElementById("monsterBlob");

    // Modals
    const modal = document.getElementById("modal");
    const modalText = document.getElementById("modalText");
    const closeBtn = document.getElementById("closeBtn");
    const copyBtn  = document.getElementById("copyBtn");
    const sos = document.getElementById("sos");
    const sosMsg = document.getElementById("sosMsg");
    const sosLink = document.getElementById("sosLink");
    const sosClose = document.getElementById("sosClose");
    const sosReset = document.getElementById("sosReset");
    // Help modal
    const help = document.getElementById("help");
    const helpBtn = document.getElementById("helpBtn");
    const helpClose = document.getElementById("helpClose");

    
    // ---------- Layout glue ----------
    function updateStackHeight(){
    if (!phone) return;

    const phoneRect    = phone.getBoundingClientRect();
    const cardsTop     = cards ? cards.getBoundingClientRect().top : phoneRect.bottom;
    const composerTop  = composer ? composer.getBoundingClientRect().top : phoneRect.bottom;

    // The stack is everything from the top edge of the first box (cards or composer)
    // down to the bottom of the phone container.
    const firstStackTop = Math.min(cardsTop, composerTop);
    let stackH = phoneRect.bottom - firstStackTop;

    // safety clamps + tiny cushion for outer margins
    stackH = Math.max(0, Math.round(stackH) + 8);

    phone.style.setProperty("--stackH", stackH + "px");
    }


    // Keep chairs glued on textarea growth / zoom / resize
    const ro = new ResizeObserver(() => {
        updateStackHeight();
        // if user was at bottom, keep pinned
        scrollTimeline();
    });
    if (composer) ro.observe(composer);
    if (cards) ro.observe(cards);

    window.addEventListener("resize", updateStackHeight);

    // ---------- FIXED Animation System ----------
    let animationTimeouts = new Set();

    // Clear all animation timeouts
    function clearAnimationTimeouts() {
        animationTimeouts.forEach(timeout => clearTimeout(timeout));
        animationTimeouts.clear();
    }

    // Set character state with proper cleanup
    function setCharacterState(character, state) {
  const blob = character === 'self' ? selfBlob : monsterBlob;
  if (!blob) return;

  const chair = blob.closest('.chair');

  // Remove blob state classes
  blob.classList.remove('state-idle','state-active','state-talking','state-listening');

  // Remove chair state helpers
  if (chair){
    chair.classList.remove('speaking','active');
  }

  // Add new blob state (or leave idle with no class)
  if (state && state !== 'idle') {
    blob.classList.add(`state-${state}`);   
  }

  // Reflect to chair for subtle physical response
  if (chair){
    if (state === 'talking') chair.classList.add('speaking');
    if (state === 'active')  chair.classList.add('active');
  }
}


    // Reset both characters to idle
    function resetToIdle() {
        clearAnimationTimeouts();
        setCharacterState('self', 'idle');
        setCharacterState('monster', 'idle');
    }

    // Set active character (for input mode)
    function setActiveCharacter(activeRole) {
        clearAnimationTimeouts();
        
        if (activeRole === 'self') {
        setCharacterState('self', 'active');
        setCharacterState('monster', 'idle');
        } else if (activeRole === 'monster') {
        setCharacterState('monster', 'active');
        setCharacterState('self', 'idle');
        } else {
        resetToIdle();
        }
    }

    // Smoothly return both blobs to neutral without snapping.
// After the tween, we restore focus/active highlight to `nextFocusRole`
// (or idle if 'lumen').
function settleToNeutral(nextFocusRole) {
  const blobs = [selfBlob, monsterBlob];

  // 1) Freeze current animated transform as inline style
  blobs.forEach(b => {
    const cs = getComputedStyle(b);
    const cur = cs.transform === 'none' ? 'matrix(1,0,0,1,0,0)' : cs.transform;

    // kill state classes so keyframes stop driving transform
    b.classList.remove('state-talking','state-listening','state-active','state-idle');

    // freeze pose and prep transition
    b.style.transform   = cur;
    b.style.transition  = 'transform 260ms cubic-bezier(.22,.61,.36,1), box-shadow 260ms ease';
  });

  // 2) Next frame: tween to neutral transform
  requestAnimationFrame(() => {
    blobs.forEach(b => {
      b.style.transform = 'translateY(0) scale(1) rotate(0)';
      // optional: fade out any extra glow quickly
      // b.style.boxShadow = '';
    });

    // 3) After tween: cleanup inline styles and restore target state
    setTimeout(() => {
      blobs.forEach(b => {
        b.style.transition = '';
        b.style.transform  = '';
        // b.style.boxShadow  = '';
      });

      if (nextFocusRole === 'lumen') {
        resetToIdle();
      } else if (nextFocusRole === 'self' || nextFocusRole === 'monster') {
        setActiveCharacter(nextFocusRole);
      } else {
        resetToIdle();
      }
    }, 280); // keep in sync with transition duration
  });
}


    // Animate speaking character
    function setSpeaking(speakingRole, duration = 1500, tail = SPEAK_TAIL) {
  clearAnimationTimeouts();

  // set current speaking/listening state
  if (speakingRole === 'self') {
    setCharacterState('self', 'talking');
    setCharacterState('monster', 'listening');
  } else if (speakingRole === 'monster') {
    setCharacterState('monster', 'talking');
    setCharacterState('self', 'listening');
  } else if (speakingRole === 'lumen') {
    setCharacterState('self', 'listening');
    setCharacterState('monster', 'listening');
  }

  // if duration <= 0, hold the pose until something else changes it
  if (duration <= 0) return;

  // after main duration, linger a bit (tail), then glide home
  const t1 = setTimeout(() => {
    // calm listening pose during the tail
    setCharacterState('self', 'listening');
    setCharacterState('monster', 'listening');

    const t2 = setTimeout(() => {
      // <‚Äî this is where we used to snap; now we tween
      if (speakingRole === 'lumen') {
        settleToNeutral('lumen');      // glide both to idle
      } else {
        settleToNeutral(speakingRole); // glide, then re-highlight current speaker as active
      }
    }, Math.max(0, tail));

    animationTimeouts.add(t2);
  }, Math.max(0, duration));

  animationTimeouts.add(t1);
}


    // ---------- Helpers ----------
    function paintPills(n){
        pills.forEach((p,i)=> {
        p.classList.toggle("on", i < n);
        p.setAttribute("aria-label", i < n ? `Step ${i+1} completed` : `Step ${i+1}`);
        });
    }

    function setComposerRole(){
        const placeholder = role === "self" ? "Type as SELF‚Ä¶" : "Type as MONSTER‚Ä¶";
        t.placeholder = placeholder;
        t.setAttribute("aria-label", `Message input ‚Äî ${placeholder}`);
        setActiveCharacter(role);
    }

    function setDisabled(on){
        inFlight = on;
        t.disabled = on;
        sendBtn.disabled = on;
        composer.classList.toggle("disabled", on);

        if (on) {
        statusBar.textContent = "Processing...";
        statusBar.className = "status-bar connecting";
        } else {
        statusBar.className = "status-bar";
        }
    }

    function scrollTimeline(){
        requestAnimationFrame(() => {
        timeline.scrollTop = timeline.scrollHeight;
        });
    }

    function showError(message, duration = 5000) {
        errorMessage.textContent = message;
        errorMessage.classList.add("show");
        setTimeout(() => {
        errorMessage.classList.remove("show");
        }, duration);
    }

    function clearError() {
        errorMessage.classList.remove("show");
    }

    function makeEntry(roleName, text){
        const row = document.createElement("div");
        row.className = "entry " + roleName;
        const bub = document.createElement("div");
        bub.className = "bubble";
        bub.setAttribute("role", "article");
        if (text) bub.textContent = text;
        row.appendChild(bub);
        return {row, bub};
    }

    function addUserEntry(roleName, text){
    const {row, bub} = makeEntry(roleName, text);
    timeline.appendChild(row);
    const tag = document.createElement("div");
    tag.className = "tag " + (roleName==="self"?"left":"right");
    tag.textContent = roleName.toUpperCase();
    timeline.appendChild(tag);
    scrollTimeline();

    // Show speaking animation
    setSpeaking(roleName, 1500);

    return {row, bub};
    }

    function addTypingEntry(){
        const {row, bub} = makeEntry("lumen", "");
        row.classList.add("typing");
        row.setAttribute("aria-label", "Lumen is typing");

        const label = document.createElement("span");
        label.textContent = "Lumen is typing ";
        const dots = document.createElement("span");
        dots.className = "dots";
        dots.innerHTML = "<span></span><span></span><span></span>";
        dots.setAttribute("aria-hidden", "true");

        bub.appendChild(label);
        bub.appendChild(dots);
        timeline.appendChild(row);

        const tag = document.createElement("div");
        tag.className = "tag";
        tag.textContent = "LUMEN";
        timeline.appendChild(tag);
        scrollTimeline();

        setSpeaking('lumen', 0); // Lumen preparing to speak
        return {row, bub, tag};
    }

    function typewriter(node, text, speed, done){
        node.textContent = "";
        let i = 0;
        node.classList.add("loading");

        const len = text.length;
        const dyn = len > 600 ? 4 : len > 400 ? 6 : len > 250 ? 8 : len > 120 ? 10 : 12;
        const delay = Math.min(speed || dyn, dyn);

        setSpeaking('lumen', text.length * delay + 500); // Speaking for duration of typing

        (function go(){
        if (i < text.length) {
            node.textContent += text.charAt(i++);
            requestAnimationFrame(scrollTimeline);
            setTimeout(go, delay);
        } else {
            node.classList.remove("loading");
            // Animation will auto-reset via timeout in setSpeaking
            if (done) done();
        }
        })();
    }

    function openReflection(text){
        modal.classList.add("open");
        modal.setAttribute("aria-hidden", "false");
        typewriter(modalText, text, SPEED_CHAR_MODAL, ()=>{});
        closeBtn.focus();
    }

    function closeReflection(){
        modal.classList.remove("open");
        modal.setAttribute("aria-hidden", "true");
        modalText.textContent = "";
        t.focus();
    }

    function openSOS(message, hotlinesUrl, resourcesUrl){
    sosMsg.textContent = message || "We identified harmful words in your conversation. Life is worth living ‚Äî you are not alone.";

    // Hotlines link
    if (hotlinesUrl) {
        sosLink.href = hotlinesUrl;
        sosLink.style.display = "flex";
    } else {
        sosLink.removeAttribute("href");
        sosLink.style.display = "none";
    }

    // Resources link
    const sosResources = document.getElementById("sosResources");
    if (sosResources) {
        if (resourcesUrl) {
            sosResources.href = resourcesUrl;
            sosResources.style.display = "flex";
        } else {
            sosResources.removeAttribute("href");
            sosResources.style.display = "none";
        }
    }

    sos.classList.add("open");
    sos.setAttribute("aria-hidden", "false");
    sosClose.focus();
}


    function closeSOS(){
        sos.classList.remove("open");
        sos.setAttribute("aria-hidden", "true");
    }

    async function fetchWithRetry(url, options, retries = MAX_RETRIES) {
        for (let i = 0; i < retries; i++) {
        try {
            const response = await fetch(url, options);
            if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response;
        } catch (error) {
            if (i === retries - 1) throw error;
            showError(`Connection failed, retrying... (${i + 1}/${retries})`);
            await new Promise(resolve => setTimeout(resolve, RETRY_DELAY * (i + 1)));
        }
        }
    }

    async function ensureSession(){
        if (sessionId) return;
        try {
        statusBar.textContent = "Connecting...";
        statusBar.className = "status-bar connecting";

        const r = await fetchWithRetry(BASE + "/api/session", {
            method:"POST",
            headers:{'Content-Type':'application/json'},
            body:"{}"
        });
        const j = await r.json();
        sessionId = j.sessionId;

        statusBar.className = "status-bar";
        clearError();
        } catch (error) {
        statusBar.textContent = "Connection failed";
        statusBar.className = "status-bar error";
        throw error;
        }
    }

    async function startNew(){
        sessionId = null;
        role = "self";
        steps = 0;
        paintPills(steps);
        timeline.innerHTML = "";
        setComposerRole();
        t.value = "";
        setDisabled(false);
        closeReflection();
        closeSOS();
        clearError();

        resetToIdle(); // Clean animation reset

        try {
        await ensureSession();
        } catch (error) {
        showError("Failed to start new session. Please check your connection and try again.");
        }
    }

    // ---------- Core Flow ----------
    async function handleSend(){
        if (inFlight) return;
        const text = (t.value || "").trim();
        if (!text) return;

        if (text.length > 2000) {
        showError("Message too long. Please keep it under 2000 characters.");
        return;
        }

        clearError();

        // add user bubble immediately in the timeline
        addUserEntry(role, text);
        t.value = "";

        // typing row only if about to trigger Lumen (after 6th message)
        const willTriggerLumen = (steps >= 5);
        let typingRow = null;
        if (willTriggerLumen) typingRow = addTypingEntry();

        setDisabled(true);
        try{
        await ensureSession();
        const r = await fetchWithRetry(BASE + "/api/message", {
            method:"POST",
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ sessionId, role, text })
        });

        const j = await r.json();

        // crisis -> SOS sheet
        if (j.crisis){
    if (typingRow){
        typingRow.row.remove();
        typingRow.tag.remove();
    }
    openSOS(j.alertMessage, j.hotlinesUrl, j.resourcesUrl);
            t.disabled = true;
            sendBtn.disabled = true;
            composer.classList.add("disabled");
            return;
        }

        steps++;
        paintPills(steps);

        if (j.awaitMore) {
        // mid-cycle, flip role
        role = (role === "self") ? "monster" : "self";
        setComposerRole();
        focusAfterSend = true;
            
        if (typingRow){
            typingRow.row.remove();
            typingRow.tag.remove();
        }

        } else {
            // full cycle -> Lumen reply
            const angel = (j.angel || j.lumen || "").trim();
            let lumenNode = null;

            if (typingRow){
            lumenNode = typingRow.bub;
            typingRow.bub.textContent = "";
            typingRow.row.classList.remove("typing");
            typingRow.row.removeAttribute("aria-label");
            } else {
            const made = makeEntry("lumen", "");
            timeline.appendChild(made.row);
            lumenNode = made.bub;
            const tag = document.createElement("div");
            tag.className = "tag";
            tag.textContent = "LUMEN";
            timeline.appendChild(tag);
            }

            if (angel) {
            typewriter(lumenNode, angel, SPEED_CHAR_CHAT_LUMEN, ()=>{
                lumenNode.setAttribute("aria-live", "polite");
                lumenNode.setAttribute("aria-label", "Lumen's response completed");
            });
            setTimeout(() => openReflection(angel), 1000);
            }

            // reset cycle
            role = "self";
            steps = 0;
            paintPills(steps);
            setComposerRole();
            focusAfterSend = true;

        }
            } catch (e) {
        console.error("Message send error:", e);

        if (typingRow){
            typingRow.row.remove();
            typingRow.tag.remove();
        }

        const err = makeEntry("lumen", "Network error. Please check the server and try again.");
        timeline.appendChild(err.row);
        const tag = document.createElement("div");
        tag.className="tag";
        tag.textContent="SYSTEM";
        timeline.appendChild(tag);
        scrollTimeline();

        showError("Failed to send message. Please check your connection and try again.");
        } finally {
    setDisabled(false);
    updateStackHeight(); // recalc in case textarea/cards changed

    // If we requested focus and no modal/sos is open, focus the textarea
    if (focusAfterSend && !modal.classList.contains("open") && !sos.classList.contains("open")) {
        focusAfterSend = false;
        requestAnimationFrame(() => {
        t.focus();
        try { t.setSelectionRange(t.value.length, t.value.length); } catch {}
        });
    }
    }

    }

    // ---------- Keyboard Navigation ----------
    function handleKeyNavigation(e) {
    if (e.key === 'Escape') {
        if (modal.classList.contains('open')) {
        closeReflection();
        } else if (sos.classList.contains('open')) {
        closeSOS();
        } else if (help.classList.contains('open')) {
        help.classList.remove('open');
        help.setAttribute('aria-hidden', 'true');
        }
    }
    }

    // ---------- Auto-resize textarea ----------
    function autoResize() {
        t.style.height = 'auto';
        const maxHeight = 200; // px
        const newHeight = Math.min(t.scrollHeight, maxHeight);
        t.style.height = newHeight + 'px';
        t.style.overflowY = t.scrollHeight > maxHeight ? 'auto' : 'hidden';
        updateStackHeight();
    }

    // ---------- Init ----------

    // cleanup: remove any stray dots on startup
    timeline.querySelectorAll('.dots').forEach(el => el.remove());

    (async () => {
        paintPills(steps);
        setComposerRole();

        // compute stack height after layout paints
        updateStackHeight();
        requestAnimationFrame(updateStackHeight);
        setTimeout(updateStackHeight, 100);
        resetToIdle(); // Ensure clean animation start

        try {
        await ensureSession();
        } catch (error) {
        showError("Failed to connect. Please refresh the page and try again.");
        }
    })();

    // ---------- Events ----------
    sendBtn.addEventListener("click", handleSend);

    t.addEventListener("keydown", e=>{
        if (e.key === "Enter" && !e.shiftKey){
        e.preventDefault();
        handleSend();
        }
    });

    t.addEventListener("input", autoResize);

    // Global keyboard navigation
    document.addEventListener("keydown", handleKeyNavigation);

    // Reflection modal events
    closeBtn.addEventListener("click", closeReflection);
    modal.addEventListener("click", (e)=> {
        if (e.target === modal) closeReflection();
    });

    copyBtn.addEventListener("click", async () => {
        try {
        await navigator.clipboard.writeText(modalText.textContent);
        copyBtn.textContent = "Copied!";
        copyBtn.setAttribute("aria-label", "Text copied to clipboard");
        setTimeout(()=> {
            copyBtn.textContent = "Copy";
            copyBtn.setAttribute("aria-label", "Copy reflection text");
        }, 1200);
        } catch {
        // Fallback
        const ta = document.createElement('textarea');
        ta.value = modalText.textContent;
        document.body.appendChild(ta);
        ta.select();
        try {
            document.execCommand('copy');
            copyBtn.textContent = "Copied!";
            setTimeout(()=> copyBtn.textContent = "Copy", 1200);
        } catch {
            showError("Could not copy text. Please select and copy manually.");
        }
        document.body.removeChild(ta);
        }
    });

    // SOS sheet events
    sosClose.addEventListener("click", closeSOS);
    sos.addEventListener("click", (e)=> {
        if (e.target === sos) closeSOS();
    });
    sosReset.addEventListener("click", startNew);

    // Menu burger (placeholder)
    const burger = document.querySelector('.burger');
    burger.addEventListener('click', () => {
        console.log('Menu clicked - implement settings/help menu');
    });
    burger.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        e.currentTarget.click();
        }
    });

    // Help button -> open Help sheet
    helpBtn.addEventListener("click", () => {
    help.classList.add("open");
    help.setAttribute("aria-hidden", "false");
    });

    // Close Help sheet
    helpClose.addEventListener("click", () => {
    help.classList.remove("open");
    help.setAttribute("aria-hidden", "true");
    });

    // Click outside the card to close
    help.addEventListener("click", (e) => {
    if (e.target === help) {
        help.classList.remove("open");
        help.setAttribute("aria-hidden", "true");
    }
    });

    // Online/offline detection
    window.addEventListener('online', () => {
        statusBar.className = "status-bar";
        clearError();
    });
    window.addEventListener('offline', () => {
        statusBar.textContent = "No internet connection";
        statusBar.className = "status-bar error";
        showError("You're offline. Please check your internet connection.");
    });

    // Prevent Enter when disabled
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && (t.disabled || sendBtn.disabled) && e.target === t) {
        e.preventDefault();
        }
    });

    // Auto-focus textarea on load
    setTimeout(() => {
        if (!t.disabled) t.focus();
    }, 100);

    // Recompute on orientation/zoom heuristics
    window.addEventListener('orientationchange', updateStackHeight);
    })();
    </script>
    </body>
    </html> 